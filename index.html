<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>paint??</title>
    <script src="https://aframe.io/releases/1.0.4/aframe.min.js"></script>
    <script src="https://unpkg.com/aframe-look-at-component@0.8.0/dist/aframe-look-at-component.min.js"></script>
    <script src="https://unpkg.com/aframe-text-geometry-component/dist/aframe-text-geometry-component.min.js"></script>
    <script src="src/glow.js"></script>
    <script type="text/javascript">
      /* jshint esversion: 6 */
      AFRAME.registerComponent('colorable', {
        init: function() {
          var el = this.el;
          el.addEventListener('click', function(event) {
            var currentColor = document.querySelector('a-scene').systems['color-select'].currentColor.getHexString();
            el.setAttribute("color", '#' + currentColor);
          });
        },
      });

      AFRAME.registerComponent('spiral-lights', {
        // represents a spiral of glowing, pulsing spheres on a sphere with the player at the center of the sphere. Formulas from here: https://mathworld.wolfram.com/SphericalSpiral.html
        schema: {
          sphereRadius: {type: 'number', default: 5}, // radius of the large sphere on which we put the spiral
          a: {type: 'number', default: 1}, // arbitrary constant from the Wolfram link
          samplingFrequency: {type: 'number', default: 5}, // number of samples to take per time t.
          glowingSphereRadius: {type: 'number', default: 0.05},
          colorHexString: {type: 'color', default: '#ffffff'}, // must include # symbol for now because it glitches out otherwise
          rotation: {type: 'number', default: 0}, // rotation in degrees about the y-axis for the spiral. Unfortunately, we can't add this directly in the rotation attribute of the entity itself because the glow mesh assumes the entity's rotation is 0 0 0, or else the glow mesh will be incorrectly oriented and will appear as a glowing object from some angles and as a semi-transparent bubble from others.
        },

        // given a time t, calculate the coordinates of the center of a sphere and return a THREE.Vector3
        getCoordinates: function(t) {
          var a = this.data.a;
          var denominator = Math.sqrt(1 + a * a + t * t);
          var x = Math.cos(t) / denominator;
          var y = Math.sin(t) / denominator;
          var z = -a * t / denominator;
          var axis = new THREE.Vector3( 0, 1, 0 ); // rotate around y-axis which in A-frame points straight up and down
          var position = new THREE.Vector3(x, z, -y).multiplyScalar(this.data.sphereRadius);
          return position.applyAxisAngle(axis, this.data.rotation * Math.PI / 180); // this is not a typo-- the Wolfram formula has z-axis pointing up, but in Aframe that's the y-axis.
        },

        // returns an a-sphere given a t
        createGlowingSphere: function(t) {
            var sphere = document.createElement('a-sphere');
            sphere.setAttribute('radius', this.data.glowingSphereRadius);
            sphere.setAttribute('glow', 'c:0.2; p:1.4; scale:3; color: ' + this.data.colorHexString);
            var coordinates = this.getCoordinates(t);
            sphere.setAttribute('position', coordinates.x + ' ' + coordinates.y + ' ' + coordinates.z);
            sphere.setAttribute('pulsing-glow', '');
            return sphere;
        },

        init: function() {
          // initialize the middle one, at t = 0, and then move upwards and downwards until the sphere's center passes a certain threshold.
          // TODO: see if you can find a better upper bound than this magic number... this is hardcoded assuming default parameters
          var documentFragment = document.createDocumentFragment();
          for (let t = 0; t < 2; t += 1 / this.data.samplingFrequency) {
            if (t == 0) {
              continue; // prevent weird overlapping spheres near t = 0.
            }
            documentFragment.appendChild(this.createGlowingSphere(t * t)); // using squre of t doesn't change the shape, but changes which points get sampled. The Wolfram formula spreads out points near t = 0 and compresses them near t = +/- infinity, so this adjusts for that
            documentFragment.appendChild(this.createGlowingSphere(-t * t));
          }
          this.el.appendChild(documentFragment);
        },
      });

      AFRAME.registerComponent('pulsing-glow', {
        schema: {
          expandingTime: {type: 'number', default: 1},
          shrinkingTime: {type: 'number', default: 3},
          minScale: {type: 'number', default: 2},
          randomTime: {type: 'boolean', default: true} // Introduce noise to how frequently this glowing entity pulses. To make this simpler, just calculate it once for now. TODO: could make this recompute every tick
        },

        init: function() {
          this.expanding = false;
          this.originalScale = Number(this.el.getAttribute('glow').scale); // must be at least 1
          this.assumedTicksPerSecond = 40;
          this.expandingDelta = (this.originalScale - 1) / this.assumedTicksPerSecond / this.data.expandingTime;
          this.shrinkingDelta = (this.originalScale - 1) / this.assumedTicksPerSecond / this.data.shrinkingTime;
          if (this.data.randomTime) {
            var randomTimeMultiplier = (Math.random() - 0.5) / 5;
            this.expandingDelta *= 1 + randomTimeMultiplier;
            this.shrinkingDelta *= 1 + randomTimeMultiplier;
          }
        },

        tick: function() {
          var r = Number(this.el.getAttribute('glow').scale);
          if (r <= this.data.minScale) {
            this.el.setAttribute('expanding', true);
          }
          else if (r >= this.originalScale) {
            this.el.setAttribute('expanding', false);
          }
          // Ah, Javascript, you and your types >:) must check for the string 'true'
          if (this.el.getAttribute('expanding') == 'true') {
            r += this.expandingDelta;
          }
          else {
            r -= this.shrinkingDelta;
          }
          this.el.setAttribute('glow', 'scale:' + r);
        }
      });

      AFRAME.registerComponent('light-switch', {
        init: function() {
          var colors = ['red', 'green', 'blue', 'yellow', 'aquamarine', 'purple', 'firebrick', 'white']; // hardcoding yay! TODO
          function createSpiral(i) {
            var rotationDegrees = 45 * i;
            var colorHexString = '#' + new THREE.Color(colors[i]).getHexString();
            var spiral = document.createElement('a-entity');
            spiral.setAttribute('spiral-lights', 'colorHexString:' + colorHexString + '; rotation:' + rotationDegrees);
            setTimeout(function() {document.getElementById('lights-container').appendChild(spiral);}, Math.random() * 3000); // TODO don't get by id
          }
          this.clicked = false;
          this.el.addEventListener('click', function (event) {
            if (this.clicked) {
              return;
            }
            console.log('I was clicked at: ', event.detail.intersection.point);
            for (let i = 0; i < 8; i++) {
              createSpiral(i);
            }
            this.clicked = true;
          });
        }
      });
    </script>
</head>
<body>
  <a-scene id="scene">
    <a-sky color="black"></a-sky>
    <a-camera look-controls position="0 0 0" wasd-controls="fly:true">
      <a-cursor></a-cursor>
    </a-camera>
    <a-entity position="0 0 -1">
      <a-circle color="blue" radius="0.4" side="double" light-switch>
        <!-- Why does this text positioning work? I don't know either -->
        <a-entity position="0.417 0 0.01" text="value: Click me; color: white"></a-entity>
      </a-circle>
    </a-entity>
    <a-entity id="lights-container"></a-entity>
  </a-scene>
</body>
</html>
