<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>paint??</title>
    <script src="https://aframe.io/releases/1.0.4/aframe.min.js"></script>
    <script src="https://unpkg.com/aframe-look-at-component@0.8.0/dist/aframe-look-at-component.min.js"></script>
    <script src="https://unpkg.com/aframe-text-geometry-component/dist/aframe-text-geometry-component.min.js"></script>
    <script src="src/glow.js"></script>
    <script type="text/javascript">
      /* jshint esversion: 6 */
      AFRAME.registerComponent('current-color-display', {
        init: function() {
          var system = document.querySelector('a-scene').systems['color-select'];
          system.registerCurrentColorDisplay(this.el);
        }
      });

      AFRAME.registerSystem('color-select', {
        init: function() {
          this.currentColor = new THREE.Color('white'); // Must always be a THREE.Color
          this.currentColorDisplay = null;
        },

        // Current color display shows the current paintbrush color
        registerCurrentColorDisplay(currentColorDisplay) {
          this.currentColorDisplay = currentColorDisplay;
        },

        // Set the current paintbrush color
        setCurrentColor(color) {
          // TODO: need to ensure that this.currentColorDisplay is initialized
          this.currentColor = new THREE.Color(color);
          this.currentColorDisplay.setAttribute("color", color);
        },
      });

      AFRAME.registerComponent('color-select', {
        init: function() {
          var el = this.el;
          var system = this.system;
          el.addEventListener('click', function (event) {
            console.log('I was clicked at: ', event.detail.intersection.point);
            system.setCurrentColor(el.getAttribute("color"));
          });
        }
      });

      AFRAME.registerComponent('colorable', {
        init: function() {
          var el = this.el;
          el.addEventListener('click', function(event) {
            var currentColor = document.querySelector('a-scene').systems['color-select'].currentColor.getHexString();
            el.setAttribute("color", '#' + currentColor);
          });
        },
      });

      AFRAME.registerComponent('mosaic-grid', {
        init: function() {
          var rows = 10;
          var cols = 10;
          var height = 0.2;
          var width = 0.2;
          var depth = 4;
          for (let i = 0; i < rows; i++) {
            for (let j = 0; j < cols; j++) {
              var mosaicTile = document.createElement('a-plane');
              mosaicTile.setAttribute('width', width);
              mosaicTile.setAttribute('height', height);
              var worldLocations = this.coordinateToWorldLocation(i, j, rows, cols, height, width, depth);
              mosaicTile.setAttribute('position', worldLocations);
              var randomColor = Math.floor(Math.random()*16777215).toString(16);
              mosaicTile.setAttribute('color', '#' + randomColor);
              mosaicTile.setAttribute('colorable', '');
              this.el.appendChild(mosaicTile);
            }
          }
        },

        // Returns string "x y z" that can be plugged directly into position. Assumes centered at 0, 0.
        coordinateToWorldLocation: function(row, col, rows, cols, height, width, depth) {
          var leftmostWorldX = -1 * cols / 2 * width;
          var topmostWorldY = rows / 2 * height;
          var x = leftmostWorldX + width * col + width / 2;
          var y = topmostWorldY - height * row - height / 2;
          return x + " " + y + " -" + depth;
        }
      });
      AFRAME.registerComponent('spiral-lights', {
        // represents a spiral of glowing, pulsing spheres on a sphere with the player at the center of the sphere. Formulas from here: https://mathworld.wolfram.com/SphericalSpiral.html
        schema: {
          sphereRadius: {type: 'number', default: 5}, // radius of the large sphere on which we put the spiral
          a: {type: 'number', default: 1}, // arbitrary constant from the Wolfram link
          samplingFrequency: {type: 'number', default: 5}, // number of samples to take per time t.
          glowingSphereRadius: {type: 'number', default: 0.05},
          colorHexString: {type: 'color', default: '#ffffff'}, // must include # symbol for now because it glitches out otherwise
          rotation: {type: 'number', default: 0}, // rotation in degrees about the y-axis for the spiral. Unfortunately, we can't add this directly in the rotation attribute of the entity itself because the glow mesh assumes the entity's rotation is 0 0 0, or else the glow mesh will be incorrectly oriented and will appear as a glowing object from some angles and as a semi-transparent bubble from others.
        },

        // given a time t, calculate the coordinates of the center of a sphere and return a THREE.Vector3
        getCoordinates: function(t) {
          var a = this.data.a;
          var denominator = Math.sqrt(1 + a * a + t * t);
          var x = Math.cos(t) / denominator;
          var y = Math.sin(t) / denominator;
          var z = -a * t / denominator;
          var axis = new THREE.Vector3( 0, 1, 0 ); // rotate around y-axis which in A-frame points straight up and down
          var position = new THREE.Vector3(x, z, -y).multiplyScalar(this.data.sphereRadius);
          return position.applyAxisAngle(axis, this.data.rotation * Math.PI / 180); // this is not a typo-- the Wolfram formula has z-axis pointing up, but in Aframe that's the y-axis.
        },

        // returns an a-sphere given a t
        createGlowingSphere: function(t) {
            var sphere = document.createElement('a-sphere');
            sphere.setAttribute('radius', this.data.glowingSphereRadius);
            sphere.setAttribute('glow', 'c:0.2; p:1.4; scale:3; color: ' + this.data.colorHexString);
            var coordinates = this.getCoordinates(t);
            sphere.setAttribute('position', coordinates.x + ' ' + coordinates.y + ' ' + coordinates.z);
            sphere.setAttribute('pulsing-glow', '');
            return sphere;
        },

        init: function() {
          // initialize the middle one, at t = 0, and then move upwards and downwards until the sphere's center passes a certain threshold.
          // TODO: see if you can find a better upper bound than this magic number... this is hardcoded assuming default parameters
          var documentFragment = document.createDocumentFragment();
          for (let t = 0; t < 2; t += 1 / this.data.samplingFrequency) {
            if (t == 0) {
              continue; // prevent weird overlapping spheres near t = 0.
            }
            documentFragment.appendChild(this.createGlowingSphere(t * t)); // using squre of t doesn't change the shape, but changes which points get sampled. The Wolfram formula spreads out points near t = 0 and compresses them near t = +/- infinity, so this adjusts for that
            documentFragment.appendChild(this.createGlowingSphere(-t * t));
          }
          this.el.appendChild(documentFragment);
        },
      });

      AFRAME.registerComponent('palette', {
        // makes the palette face the origin so that the plane of the color circles is perfectly lined up when the player looks at it. This requires a rotation about the x-axis.
        init: function() {
          var yPos = this.el.getAttribute('position').y;
          var zPos = this.el.getAttribute('position').z;
          var xRotation = -Math.atan(yPos / zPos) * 180 / Math.PI; // Aframe uses degrees
          this.el.setAttribute('rotation', xRotation + " 0 0");
        }
      });

      AFRAME.registerComponent('pulsing-glow', {
        schema: {
          expandingTime: {type: 'number', default: 1},
          shrinkingTime: {type: 'number', default: 3},
          minScale: {type: 'number', default: 2},
          randomTime: {type: 'boolean', default: true} // Introduce noise to how frequently this glowing entity pulses. To make this simpler, just calculate it once for now. TODO: could make this recompute every tick
        },

        init: function() {
          this.expanding = false;
          this.originalScale = Number(this.el.getAttribute('glow').scale); // must be at least 1
          this.assumedTicksPerSecond = 40;
          this.expandingDelta = (this.originalScale - 1) / this.assumedTicksPerSecond / this.data.expandingTime;
          this.shrinkingDelta = (this.originalScale - 1) / this.assumedTicksPerSecond / this.data.shrinkingTime;
          if (this.data.randomTime) {
            var randomTimeMultiplier = (Math.random() - 0.5) / 5;
            this.expandingDelta *= 1 + randomTimeMultiplier;
            this.shrinkingDelta *= 1 + randomTimeMultiplier;
          }
        },

        tick: function() {
          var r = Number(this.el.getAttribute('glow').scale);
          if (r <= this.data.minScale) {
            this.el.setAttribute('expanding', true);
          }
          else if (r >= this.originalScale) {
            this.el.setAttribute('expanding', false);
          }
          // Ah, Javascript, you and your types >:) must check for the string 'true'
          if (this.el.getAttribute('expanding') == 'true') {
            r += this.expandingDelta;
          }
          else {
            r -= this.shrinkingDelta;
          }
          this.el.setAttribute('glow', 'scale:' + r);
        }
      });
    </script>
</head>
<body>
  <a-scene id="scene">
    <a-sky color="black"></a-sky>
    <a-camera look-controls position="0 0 0" wasd-controls="fly:true">
      <a-cursor></a-cursor>
      <a-entity position="0.5 0.5 -1">
        <a-entity position="0.44 0.105 0" text="value: Color; color: white"></a-entity> <!-- no clue why this positioning puts it above the color circle but it does -->
        <a-entity>
          <a-circle id="current-color-circle" radius="0.05" current-color-display></a-circle>
          <!-- <a-ring id="current-color-ring" radius-inner="0.05" radius-outer="0.055" color="black"></a-ring> -->
        </a-entity>
      </a-entity>
    </a-camera>
    <!-- <a-sphere color="yellow" position="0 0 0" radius="10" material="side: double"></a-sphere> -->
    <a-entity position="0 -2 -4" palette>
      <a-circle color="red" position="-1 0 0" radius="0.4" color-select side="double"></a-circle>
      <a-circle color="green" position="0 0 0" radius="0.4" color-select side="double"></a-circle>
      <a-circle color="blue" position="1 0 0" radius="0.4" color-select side="double"></a-circle>
    </a-entity>
    <a-entity spiral-lights="colorHexString:#ff0000"></a-entity> <!-- red -->
    <a-entity spiral-lights="colorHexString:#0000ff; rotation:45"></a-entity> <!-- blue -->
    <a-entity spiral-lights="colorHexString:#00ff00; rotation:90"></a-entity> <!-- green -->
    <a-entity spiral-lights="colorHexString:#ffff00; rotation:135"></a-entity> <!-- yellow -->
    <a-entity spiral-lights="colorHexString:#ff00ff; rotation:180"></a-entity> <!--  -->
    <a-entity spiral-lights="colorHexString:#00ffff; rotation:225"></a-entity> <!--  -->
    <a-entity spiral-lights="colorHexString:#87ceeb; rotation:270"></a-entity> <!-- sky blue -->
    <a-entity spiral-lights="colorHexString:#FFA500; rotation:315"></a-entity> <!-- orange -->

    <!-- <a-sphere glow="c:0.2; p:1.4;scale:3" position="1 0.5 -3" radius="0.05" pulsing-glow></a-sphere> -->
<!--     <a-sphere glow="c:0.2; p:1.4;scale:3" position="-1 0.5 -3" radius="0.05" pulsing-glow></a-sphere>
    <a-sphere glow="c:0.2; p:1.4;scale:3" position="1 -0.5 -3" radius="0.05" pulsing-glow></a-sphere>
    <a-sphere glow="c:0.2; p:1.4;scale:3" position="-1 -0.5 -3" radius="0.05" pulsing-glow></a-sphere>
 -->
<!--     <a-sphere glow="c:0.2; p:1.4;scale:3" position="1 0.5 3" radius="0.05" pulsing-glow></a-sphere>
    <a-sphere glow="c:0.2; p:1.4;scale:3" position="-1 0.5 3" radius="0.05" pulsing-glow></a-sphere>
    <a-sphere glow="c:0.2; p:1.4;scale:3" position="1 -0.5 3" radius="0.05" pulsing-glow></a-sphere>
    <a-sphere glow="c:0.2; p:1.4;scale:3" position="-1 -0.5 3" radius="0.05" pulsing-glow></a-sphere> -->
    <!-- <a-entity mosaic-grid></a-entity> -->
  </a-scene>
</body>
</html>
